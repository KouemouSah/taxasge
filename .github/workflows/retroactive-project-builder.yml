# ============================================================================
# 🗂️ TaxasGE Retroactive Project Builder
# ============================================================================
# Workflow de construction rétroactive de la structure projet (Projects v2)
# Déclenché sur: Lancement manuel (workflow_dispatch) avec options
# (context_file, create_project, create_milestones, organize_issues)
#
# Features:
# - Lecture du contexte historique (docs/historical-context.json par défaut)
# - Création d’un GitHub Project V2 (GraphQL) et champs custom (Priority, Component, Phase, Estimation)
# - Génération de milestones par phase (0→5) avec dates/états
# - Organisation automatique des issues ouvertes vers les milestones (matching mots-clés)
# - Génération d’un résumé project-summary.json
# - Upload en artifact et auto-commit dans docs/
# - Récapitulatif clair (URLs/IDs) en fin de job
#
# Permissions requises:
# - contents: read • issues: write • repository-projects: write
# Environnement: ubuntu-latest • Python 3.11
# APIs: GitHub REST v3 + GraphQL
#
# Author: KOUEMOU SAH Jean Emac
# ============================================================================


name: 🗂️ TaxasGE Retroactive Project Builder

on:
  workflow_dispatch:
    inputs:
      context_file:
        description: 'Fichier contexte historique à utiliser'
        required: false
        default: 'docs/historical-context.json'
        type: string
      create_project:
        description: 'Créer le GitHub Project'
        required: false
        default: 'true'
        type: choice
        options:
        - 'true'
        - 'false'
      create_milestones:
        description: 'Créer les milestones'
        required: false
        default: 'true'
        type: choice
        options:
        - 'true'
        - 'false'
      organize_issues:
        description: 'Organiser les issues existantes'
        required: false
        default: 'true'
        type: choice
        options:
        - 'true'
        - 'false'

permissions:
  contents: write          # <-- fix: nécessaire pour le commit/push
  issues: write
  repository-projects: write

jobs:
  retroactive-project-builder:
    name: 🗂️ Build Retroactive Project Structure
    runs-on: ubuntu-latest
    
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4
        
      - name: 🐍 Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: 📦 Install dependencies
        run: |
          pip install requests python-dateutil
          
      - name: 🔍 Create Retroactive Project Builder Script
        run: |
          cat > retroactive_project_builder.py << 'EOF'
          import os
          import json
          import requests
          from datetime import datetime, timedelta
          from dateutil.relativedelta import relativedelta
          import time
          
          class TaxasGERetroactiveProjectBuilder:
              def __init__(self, token, repo_owner, repo_name):
                  self.token = token
                  self.repo_owner = repo_owner
                  self.repo_name = repo_name
                  self.repo_id = None
                  self.owner_id = None
                  self.owner_type = None
                  self.project_id = None
                  
                  # Token GraphQL (Projects v2) : préférer PROJECTS_TOKEN (PAT), sinon GITHUB_TOKEN
                  self.projects_token = os.getenv("PROJECTS_TOKEN") or token
                  
                  # REST API headers (issues/milestones)
                  self.headers = {
                      "Authorization": f"token {token}",
                      "Accept": "application/vnd.github.v3+json",
                      "User-Agent": "TaxasGE-Project-Builder/1.0"
                  }
                  
                  # GraphQL headers (Projects V2)
                  self.graphql_headers = {
                      "Authorization": f"Bearer {self.projects_token}",
                      "Content-Type": "application/json",
                      "User-Agent": "TaxasGE-Project-Builder/1.0"
                  }
                  
                  self.graphql_url = "https://api.github.com/graphql"
                  
              def load_historical_context(self, context_file):
                  print(f"📄 Chargement contexte: {context_file}")
                  try:
                      with open(context_file, 'r', encoding='utf-8') as f:
                          context = json.load(f)
                      print(f"✅ Contexte chargé: {context['metadata']['overall_progress']}% progression")
                      return context
                  except FileNotFoundError:
                      print(f"❌ Fichier contexte non trouvé: {context_file}")
                      return None
                  except json.JSONDecodeError as e:
                      print(f"❌ Erreur parsing JSON: {e}")
                      return None
              
              def get_repository_info(self):
                  url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}"
                  response = requests.get(url, headers=self.headers)
                  if response.status_code == 200:
                      repo_data = response.json()
                      self.repo_id = repo_data['node_id']
                      self.owner_id = repo_data['owner']['node_id']   # Projects v2 = owner (user/org)
                      self.owner_type = repo_data['owner'].get('type')  # "Organization" ou "User"
                      print(f"✅ Repository ID: {self.repo_id}")
                      print(f"✅ Owner ID (Projects V2): {self.owner_id} ({self.owner_type})")
                      using_pat = "PROJECTS_TOKEN (secret GH_PROJECTS_TOKEN)" if os.getenv("PROJECTS_TOKEN") else "GITHUB_TOKEN (permissions limitées)"
                      print(f"🔐 Token GraphQL utilisé pour Projects v2: {using_pat}")
                      return repo_data
                  else:
                      print(f"❌ Erreur récupération repo: {response.status_code}")
                      return None
              
              # ---------- Projects V2 helpers ----------
              def find_existing_project_v2(self, title):
                  """Retourne le projet v2 existant par titre (si trouvé), sinon None."""
                  query = """
                  query FindProjects($ownerId: ID!) {
                    node(id: $ownerId) {
                      ... on Organization {
                        projectsV2(first: 50, orderBy: {field: UPDATED_AT, direction: DESC}) {
                          nodes { id title number url }
                        }
                      }
                      ... on User {
                        projectsV2(first: 50, orderBy: {field: UPDATED_AT, direction: DESC}) {
                          nodes { id title number url }
                        }
                      }
                    }
                  }
                  """
                  variables = {"ownerId": self.owner_id}
                  r = requests.post(self.graphql_url, headers=self.graphql_headers, json={"query": query, "variables": variables})
                  if r.status_code != 200:
                      print(f"⚠️  Impossible de lister les Projects v2 (HTTP {r.status_code})")
                      return None
                  data = r.json()
                  nodes = []
                  try:
                      node = data["data"]["node"]
                      if node and "projectsV2" in node:
                          nodes = node["projectsV2"]["nodes"]
                  except Exception:
                      pass
                  for p in nodes or []:
                      if p.get("title") == title:
                          print(f"ℹ️  Project v2 existant trouvé: {p['title']} ({p['url']})")
                          return p
                  return None
              
              def get_project_fields(self, project_id):
                  """Liste les champs existants d'un Project v2 (par nom)."""
                  query = """
                  query Fields($projectId: ID!) {
                    node(id: $projectId) {
                      ... on ProjectV2 {
                        fields(first: 50) {
                          nodes {
                            __typename
                            ... on ProjectV2FieldCommon { id name dataType }
                            ... on ProjectV2SingleSelectField { id name dataType options { id name } }
                          }
                        }
                      }
                    }
                  }
                  """
                  r = requests.post(self.graphql_url, headers=self.graphql_headers, json={"query": query, "variables": {"projectId": project_id}})
                  if r.status_code != 200:
                      print(f"⚠️  Impossible de lister les champs (HTTP {r.status_code})")
                      return set()
                  data = r.json()
                  names = set()
                  try:
                      nodes = data["data"]["node"]["fields"]["nodes"]
                      for n in nodes:
                          if "name" in n and n["name"]:
                              names.add(n["name"])
                  except Exception:
                      pass
                  return names
              
              def create_project_v2(self, context):
                  print("🗂️ Création du GitHub Project V2...")
                  project_title = "🎯 TaxasGE Master Project"
                  
                  # 1) Vérifier si le projet existe déjà
                  existing = self.find_existing_project_v2(project_title)
                  if existing:
                      self.project_id = existing["id"]
                      print(f"✅ Réutilisation du Project existant: {existing['title']}")
                      return existing
                  
                  # 2) Créer sinon
                  mutation = """
                  mutation CreateProject($ownerId: ID!, $title: String!) {
                    createProjectV2(input: {ownerId: $ownerId, title: $title}) {
                      projectV2 { id number title url }
                    }
                  }
                  """
                  variables = {
                      "ownerId": self.owner_id,
                      "title": project_title
                  }
                  response = requests.post(self.graphql_url, headers=self.graphql_headers, json={"query": mutation, "variables": variables})
                  if response.status_code == 200:
                      data = response.json()
                      if "errors" in data:
                          print(f"❌ Erreurs GraphQL: {data['errors']}")
                          if not os.getenv("PROJECTS_TOKEN"):
                              print("ℹ️ Conseil: fournissez un PAT avec droit 'Project: Read & write' via le secret GH_PROJECTS_TOKEN pour créer un Project v2.")
                          return None
                      project = data['data']['createProjectV2']['projectV2']
                      self.project_id = project['id']
                      print(f"✅ Project créé: {project['title']}")
                      print(f"🔗 URL: {project['url']}")
                      print(f"📊 Project ID: {self.project_id}")
                      return project
                  else:
                      print(f"❌ Erreur création projet: {response.status_code}")
                      print(f"Response: {response.text}")
                      if not os.getenv("PROJECTS_TOKEN"):
                          print("ℹ️ Conseil: utilisez un PAT dans GH_PROJECTS_TOKEN pour Projects v2.")
                      return None
              
              def setup_project_fields(self):
                  print("🔧 Configuration des champs personnalisés...")
                  if not self.project_id:
                      print("⚠️  Pas de project_id, skip champs.")
                      return []
                  
                  existing_names = self.get_project_fields(self.project_id)
                  
                  fields_to_create = [
                      {
                          "name": "Priority",
                          "dataType": "SINGLE_SELECT",
                          "options": [
                              {"name": "🚨 Critical", "color": "d73a4a"},
                              {"name": "⭐ High", "color": "d93f0b"},
                              {"name": "🔶 Medium", "color": "fbca04"},
                              {"name": "🔵 Low", "color": "0052cc"}
                          ]
                      },
                      {
                          "name": "Component", 
                          "dataType": "SINGLE_SELECT",
                          "options": [
                              {"name": "🛠️ Infrastructure", "color": "6f42c1"},
                              {"name": "🐍 Backend", "color": "f9d0c4"},
                              {"name": "📱 Mobile", "color": "e99695"},
                              {"name": "🌐 Web", "color": "c2e0c6"},
                              {"name": "🤖 AI/ML", "color": "d4c5f9"},
                              {"name": "📊 Dashboard", "color": "0e8a16"}
                          ]
                      },
                      {
                          "name": "Phase",
                          "dataType": "SINGLE_SELECT", 
                          "options": [
                              {"name": "Phase 0: Infrastructure", "color": "6f42c1"},
                              {"name": "Phase 1: Backend", "color": "f9d0c4"},
                              {"name": "Phase 2: Mobile", "color": "e99695"},
                              {"name": "Phase 3: Dashboard", "color": "c2e0c6"},
                              {"name": "Phase 4: Production", "color": "d93f0b"},
                              {"name": "Phase 5: Business", "color": "0052cc"}
                          ]
                      },
                      {
                          "name": "Estimation",
                          "dataType": "SINGLE_SELECT",
                          "options": [
                              {"name": "1 day", "color": "0e8a16"},
                              {"name": "3 days", "color": "0e8a16"}, 
                              {"name": "1 week", "color": "fbca04"},
                              {"name": "2 weeks", "color": "fbca04"},
                              {"name": "1 month", "color": "d93f0b"},
                              {"name": "2+ months", "color": "d73a4a"}
                          ]
                      }
                  ]
                  
                  created_fields = []
                  for field_config in fields_to_create:
                      if field_config["name"] in existing_names:
                          print(f"  ⏭️  Champ déjà présent: {field_config['name']}")
                          continue
                      field = self.create_project_field(field_config)
                      if field:
                          created_fields.append(field)
                          time.sleep(1)
                  print(f"✅ {len(created_fields)} champs créés (les autres existaient déjà ou ont échoué)")
                  return created_fields
              
              def create_project_field(self, field_config):
                  mutation = """
                  mutation CreateProjectField($projectId: ID!, $name: String!, $dataType: ProjectV2CustomFieldType!, $options: [ProjectV2SingleSelectFieldOptionInput!]) {
                    createProjectV2Field(input: {
                      projectId: $projectId,
                      name: $name,
                      dataType: $dataType,
                      singleSelectOptions: $options
                    }) {
                      projectV2Field { id name }
                    }
                  }
                  """
                  variables = {
                      "projectId": self.project_id,
                      "name": field_config["name"],
                      "dataType": field_config["dataType"],
                      "options": field_config.get("options", [])
                  }
                  r = requests.post(self.graphql_url, headers=self.graphql_headers, json={"query": mutation, "variables": variables})
                  if r.status_code == 200:
                      data = r.json()
                      if "errors" in data:
                          print(f"  ❌ Erreur création champ {field_config['name']}: {data['errors']}")
                          return None
                      try:
                          field = data['data']['createProjectV2Field']['projectV2Field']
                          print(f"  ✅ Champ créé: {field['name']}")
                          return field
                      except Exception as e:
                          print(f"  ❌ Réponse inattendue création champ {field_config['name']}: {data}")
                          return None
                  else:
                      print(f"  ❌ HTTP {r.status_code} à la création du champ {field_config['name']}: {r.text}")
                      return None
              
              # ---------- Milestones / Issues ----------
              def get_existing_milestones(self):
                  """Retourne dict {title: milestone} pour state=all."""
                  url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}/milestones"
                  params = {"state": "all", "per_page": 100}
                  r = requests.get(url, headers=self.headers, params=params)
                  if r.status_code != 200:
                      print(f"⚠️  Impossible de lister les milestones (HTTP {r.status_code})")
                      return {}
                  out = {}
                  for m in r.json():
                      out[m["title"]] = m
                  return out
              
              def create_milestones_from_context(self, context):
                  print("🎯 Création des milestones basés sur l'analyse...")
                  base_date = datetime.utcnow()
                  def iso_utc(dt): return dt.strftime("%Y-%m-%dT%H:%M:%SZ")
                  
                  existing = self.get_existing_milestones()
                  
                  milestones_config = []
                  infra_date = base_date - timedelta(weeks=8)
                  milestones_config.append({
                      "title": "🛠️ Infrastructure Foundation", 
                      "description": """Phase 0 - Infrastructure & AI Pipeline
          
          ✅ Accomplissements validés:
          - Firebase integration complète
          - Supabase configuration et tests
          - SonarQube setup et quality gates
          - AI Data Pipeline (PDF → JSON → Training)
          - TensorFlow Lite model (0.41MB, 100% accuracy)
          - GitHub Actions workflows
          
          📊 Statut: 95% Complété (Validé utilisateur)
          🔗 Fondation solide pour toutes les phases suivantes""",
                      "due_on": iso_utc(infra_date),
                      "state": "closed"
                  })
                  backend_date = base_date + timedelta(weeks=2)
                  milestones_config.append({
                      "title": "🐍 Backend & API Excellence",
                      "description": """Phase 1 - Backend Development
          
          ✅ Accomplissements:
          - FastAPI structure et architecture
          - Endpoints principaux (/health, /api/v1/, /docs)
          - Modèles Pydantic définis
          - Intégration Supabase opérationnelle
          
          🔄 Restant:
          - Tests unitaires complets (85% coverage target)
          - Authentication JWT finalisée
          - Documentation API complète
          
          📊 Statut: 70% Complété""",
                      "due_on": iso_utc(backend_date),
                      "state": "open"
                  })
                  mobile_date = base_date + timedelta(weeks=3)
                  milestones_config.append({
                      "title": "📱 Mobile App Critical Path",
                      "description": """Phase 2 - Mobile Development (CRITICAL PATH)
          
          ✅ Accomplissements:
          - React Native structure complète
          - Navigation et screens de base
          - Firebase integration configurée
          - AI Model ready (taxasge_model.tflite)
          
          🚨 Critique - Restant:
          - Intégration TensorFlow Lite dans l'app
          - Interface chatbot utilisateur
          - Tests multilingues (ES/FR/EN)
          - UI polish et optimisation
          
          📊 Statut: 60% Complété
          ⚠️  BLOQUE les phases suivantes""",
                      "due_on": iso_utc(mobile_date),
                      "state": "open"
                  })
                  dashboard_date = base_date + timedelta(weeks=1)
                  milestones_config.append({
                      "title": "🌐 Dashboard Excellence",
                      "description": """Phase 3 - Dashboard & Monitoring
          
          ✅ Accomplissements exceptionnels:
          - Dashboard Phases 1-3 complétées (Design/Métriques/Optimisation)
          - Interface responsive professionnelle
          - Métriques temps réel intégrées
          
          🔄 Finitions:
          - Configuration GitHub Pages finale
          - Tests accessibilité WCAG
          
          📊 Statut: 90% Complété""",
                      "due_on": iso_utc(dashboard_date),
                      "state": "open"
                  })
                  production_date = base_date + timedelta(weeks=6)
                  milestones_config.append({
                      "title": "🚀 Production Ready",
                      "description": """Phase 4 - Production Deployment
          
          🔄 Objectifs:
          - Audit sécurité complet (API, Mobile, Infrastructure)
          - Optimisation performances globales
          - Load testing et monitoring avancé
          - CI/CD Mobile (Android/iOS builds)
          - Documentation production
          
          📊 Statut: 20% Complété
          🔗 Dépend de: Phase 2 Mobile (critical path)""",
                      "due_on": iso_utc(production_date),
                      "state": "open"
                  })
                  business_date = base_date + timedelta(weeks=12)
                  milestones_config.append({
                      "title": "💳 Business Integration",
                      "description": """Phase 5 - Business Ready
          
          🔄 Objectifs:
          - Intégration paiements Bange
          - Dashboard admin Next.js
          - Analytics et reporting avancés
          - Support multi-tenant
          - Formation et documentation utilisateur
          
          📊 Statut: 10% Complété
          🔗 Dépend de: Phase 4 Production""",
                      "due_on": iso_utc(business_date),
                      "state": "open"
                  })
                  
                  created_milestones = []
                  for cfg in milestones_config:
                      if cfg["title"] in existing:
                          print(f"  ⏭️  Milestone déjà présent: {cfg['title']}")
                          created_milestones.append(existing[cfg["title"]])
                          continue
                      milestone = self.create_milestone(cfg)
                      if milestone:
                          created_milestones.append(milestone)
                          time.sleep(0.5)
                  print(f"✅ {len(created_milestones)} milestones prêts (créés ou réutilisés)")
                  return created_milestones
              
              def create_milestone(self, milestone_config):
                  url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}/milestones"
                  r = requests.post(url, headers=self.headers, json=milestone_config)
                  if r.status_code == 201:
                      m = r.json()
                      status_icon = "✅" if milestone_config.get("state") == "closed" else "🔄"
                      print(f"  {status_icon} Milestone créé: {m['title']}")
                      return m
                  else:
                      try:
                          print(f"  ❌ Erreur création milestone {milestone_config['title']}: {r.status_code} -> {r.text}")
                      except Exception:
                          print(f"  ❌ Erreur création milestone {milestone_config['title']}: {r.status_code}")
                      return None
              
              def organize_existing_issues(self, context, milestones):
                  print("🔗 Organisation des issues existantes...")
                  issues = self.get_repository_issues()
                  if not issues:
                      print("ℹ️  Aucune issue trouvée à organiser")
                      return
                  milestone_mapping = {m['title']: m for m in milestones}
                  issue_patterns = {
                      "🛠️ Infrastructure Foundation": ["firebase","supabase","sonar","infrastructure","devops","ci/cd","workflow"],
                      "🐍 Backend & API Excellence": ["backend","api","fastapi","test","unittest","auth","jwt","endpoint"],
                      "📱 Mobile App Critical Path": ["mobile","react-native","chatbot","ai","tensorflow","tflite","app"],
                      "🌐 Dashboard Excellence": ["dashboard","monitoring","status","ui","frontend","pages"],
                      "🚀 Production Ready": ["security","audit","performance","optimization","production","deploy"],
                      "💳 Business Integration": ["bange","payment","business","admin","integration"]
                  }
                  organized_count = 0
                  for issue in issues:
                      # si déjà assignée, on n'y touche pas
                      if issue.get("milestone"):
                          continue
                      assigned_milestone = self.determine_issue_milestone(issue, issue_patterns, milestone_mapping)
                      if assigned_milestone:
                          success = self.assign_milestone_to_issue(issue, assigned_milestone)
                          if success:
                              organized_count += 1
                          time.sleep(0.3)
                  print(f"✅ {organized_count} issues organisées dans les milestones")
              
              def get_repository_issues(self):
                  url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}/issues"
                  params = {"state": "open", "per_page": 100}
                  r = requests.get(url, headers=self.headers, params=params)
                  if r.status_code == 200:
                      issues = r.json()
                      issues = [i for i in issues if "pull_request" not in i]
                      print(f"📋 {len(issues)} issues trouvées")
                      return issues
                  else:
                      print(f"❌ Erreur récupération issues: {r.status_code}")
                      return []
              
              def determine_issue_milestone(self, issue, patterns, milestone_mapping):
                  issue_text = (issue['title'] + ' ' + (issue.get('body') or '')).lower()
                  milestone_scores = {}
                  for milestone_title, keywords in patterns.items():
                      score = 0
                      for keyword in keywords:
                          if keyword in issue_text:
                              score += issue_text.count(keyword)
                      if score > 0:
                          milestone_scores[milestone_title] = score
                  if milestone_scores:
                      best = max(milestone_scores.items(), key=lambda x: x[1])[0]
                      return milestone_mapping.get(best)
                  return None
              
              def assign_milestone_to_issue(self, issue, milestone):
                  url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}/issues/{issue['number']}"
                  data = {"milestone": milestone["number"]}
                  r = requests.patch(url, headers=self.headers, json=data)
                  if r.status_code == 200:
                      print(f"  🔗 Issue #{issue['number']} → {milestone['title']}")
                      return True
                  else:
                      print(f"  ❌ Erreur assignation #{issue['number']}: {r.status_code}")
                      return False
              
              def generate_project_summary(self, context, project, milestones):
                  summary = {
                      "metadata": {
                          "generated_at": datetime.now().isoformat(),
                          "repository": f"{self.repo_owner}/{self.repo_name}",
                          "project_created": bool(project)
                      },
                      "project": {
                          "title": project["title"] if project else None,
                          "url": project["url"] if project else None,
                          "number": project["number"] if project else None,
                          "id": project["id"] if project else None
                      } if project else {},
                      "milestones": [
                          {"title": m["title"], "due_date": m.get("due_on"), "state": m["state"], "number": m["number"]}
                          for m in milestones
                      ],
                      "context_analysis": {
                          "overall_progress": context["metadata"]["overall_progress"],
                          "current_phase": context["project_status"]["current_phase"],
                          "confidence_level": context["project_status"]["confidence_level"]
                      },
                      "next_steps": [
                          ("Accéder au projet: " + project["url"]) if project else "Créer le Project v2 (nécessite PAT GH_PROJECTS_TOKEN)",
                          "Vérifier l'organisation des issues dans les milestones",
                          "Configurer les vues personnalisées du projet",
                          "Commencer le travail sur la critical path: Mobile AI integration"
                      ]
                  }
                  with open("project-summary.json", "w", encoding='utf-8') as f:
                      json.dump(summary, f, indent=2, ensure_ascii=False)
                  return summary
          
          def main():
              print("🗂️ TaxasGE Retroactive Project Builder")
              print("======================================")
              
              token = os.getenv("GITHUB_TOKEN")
              repo_owner = os.getenv("REPO_OWNER")
              repo_name = os.getenv("REPO_NAME")
              context_file = os.getenv("CONTEXT_FILE", "docs/historical-context.json")
              
              create_project = os.getenv("CREATE_PROJECT", "true").lower() == "true"
              create_milestones = os.getenv("CREATE_MILESTONES", "true").lower() == "true"
              organize_issues = os.getenv("ORGANIZE_ISSUES", "true").lower() == "true"
              
              if not all([token, repo_owner, repo_name]):
                  print("❌ Variables d'environnement manquantes")
                  return
              
              builder = TaxasGERetroactiveProjectBuilder(token, repo_owner, repo_name)
              
              context = builder.load_historical_context(context_file)
              if not context:
                  print("❌ Impossible de charger le contexte historique")
                  return
              
              repo_info = builder.get_repository_info()
              if not repo_info:
                  return
              
              project = None
              milestones = []
              
              if create_project:
                  project = builder.create_project_v2(context)
                  if project:
                      builder.setup_project_fields()
                      time.sleep(2)
              
              if create_milestones:
                  milestones = builder.create_milestones_from_context(context)
              
              if organize_issues and milestones:
                  builder.organize_existing_issues(context, milestones)
              
              # Résumé (même sans projet pour debug)
              builder.generate_project_summary(context, project, milestones)
              
              if project and milestones:
                  print(f"\\n🎯 Projet TaxasGE prêt!")
                  print(f"📊 Progression globale: {context['metadata']['overall_progress']}%")
                  print(f"🗂️  Projet: {project['title']}")
                  print(f"🔗 URL: {project['url']}")
                  print(f"🎯 Milestones: {len(milestones)} prêts")
                  print(f"📋 Issues organisées automatiquement (si applicable)")
                  print(f"\\n🚀 Prochaine étape critique: Mobile AI Integration")
              else:
                  print("⚠️  Création de projet incomplète (ou déjà existant réutilisé)")
          
          if __name__ == "__main__":
              main()
          EOF
          
      - name: 🗂️ Execute Retroactive Project Builder
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}         # REST (issues/milestones)
          PROJECTS_TOKEN: ${{ secrets.GH_PROJECTS_TOKEN }}  # GraphQL Projects v2 (PAT)
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          CONTEXT_FILE: ${{ github.event.inputs.context_file }}
          CREATE_PROJECT: ${{ github.event.inputs.create_project }}
          CREATE_MILESTONES: ${{ github.event.inputs.create_milestones }}
          ORGANIZE_ISSUES: ${{ github.event.inputs.organize_issues }}
        run: |
          python retroactive_project_builder.py
          
      - name: 📄 Upload Project Summary
        uses: actions/upload-artifact@v4
        with:
          name: taxasge-project-summary
          path: project-summary.json
          retention-days: 30
          
      - name: 📄 Auto-commit Project Summary
        if: success()
        run: |
          if [ -f "project-summary.json" ]; then
            mkdir -p docs
            cp project-summary.json docs/project-summary.json
            
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action - Project Builder"
            
            git add docs/project-summary.json
            if ! git diff --staged --quiet; then
              git commit -m "🗂️ Add/Update TaxasGE project summary
              
              - Project v2 created or reused (idempotent)
              - Milestones created or reused (idempotent)
              - Issues organized when applicable"
              git push
              echo "✅ Project summary committed to docs/"
            fi
          fi
          
      - name: 📊 Display Project Creation Results
        if: success()
        run: |
          echo "🎯 TaxasGE Retroactive Project Builder terminé!"
          echo "✅ Project v2: créé OU réutilisé"
          echo "✅ Milestones: créés OU réutilisés"
          echo "✅ Issues: organisées si non déjà assignées"
          echo ""
          echo "📄 Résumé détaillé: docs/project-summary.json"


